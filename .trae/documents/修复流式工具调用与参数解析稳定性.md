## 结论

* 工具调用确实再次出错：首次流式响应中出现 OpenAI 客户端断言失败（new\_tool.type != "function"），随后工具参数只收到不完整的字符串 "{"，被错误地当作空参数执行；紧接着第二次请求被服务端判定 messages 不合法返回 400。

## 证据与定位

* 流式异常：openai/lib/streaming/chat/\_completions.py:408 触发 `assert new_tool.type == "function"`，说明模型的工具增量事件类型与库预期不一致（提供方流式工具事件兼容性问题）。

* 参数不完整：backend/editor\_agent.py:90 记录 `无法解析工具参数: '{'`，即 `tc.function.arguments` 仅是不完整片段。

* 误执行空参数：backend/tool\_framework.py:53 打印“基本信息已更新: {...None}”，来源是对空字典进行 Pydantic 校验后得到全 None 的字段并执行更新（本质是 no-op 但被当作成功）。

* 二次请求 400：日志显示 `"messages" in request are illegal.`，高概率是我们把带 `tool_calls` 的 assistant 消息或 role=tool 消息回传给当前模型/提供方，而其不完全兼容 OpenAI 工具调用消息规范。

## 根因分析

* 供应方（Siliconflow + DeepSeek-V3.2）在流式工具调用事件的格式与 OpenAI Python SDK 的处理逻辑不完全一致，导致增量解析断言失败并只拿到不完整的 `arguments`。

* 代理层未对 `arguments` 不完整/无效做严格熔断，导致空参数通过校验并执行工具。

* 回传消息含 `assistant.tool_calls` 与 `role=tool`，在该提供方的 Chat Completions 路径下可能不被允许或需不同格式，触发 400。

## 修复方案

1. 流式降级策略

* 对含 `tools` 的请求禁用流式（使用非流式 create），或在捕获 `AssertionError` 时自动回退到非流式；仅在纯文本对话启用流式。

1. 参数解析与执行熔断

* `_parse_tool_args` 返回含 `__raw__` 或解析失败时，禁止执行工具，返回“参数校验失败”并提示模型对照工具 Schema 重试。

* 若解析结果为 `{}` 或经校验得到全 None，视为无效参数，拒绝执行并走自纠提示。

1. 消息格式兼容

* 在把 `assistant.tool_calls` 写回历史前做提供方兼容判断：若模型不支持工具调用消息，改为“工具结果总结文本”回传，而非携带结构化 `tool_calls`/`role=tool`。

* 当确需回传 `tool_calls` 时，保证 `assistant.content` 为 `None` 而非空字符串，并严格遵循 OpenAI 规范。

1. 日志与提示优化

* 对 no-op 更新不再记录“已更新”，改为明确“参数为空，未执行”。

* 把 400 的原始响应及当前 `messages` 形态记录到 DEBUG 便于后续定位。

1. 兼容性验证

* 用一个最小用例分别验证：

  * 仅文本流式（应正常）。

  * 非流式 + 工具调用（应返回完整 `arguments`）。

  * 回传不含 `tool_calls` 的消息（应不再 400）。

## 计划落地步骤

1. 在 EditorAgent.run 中：为 `tools` 请求改用非流式调用；或在捕获到流式 `AssertionError` 回退到非流式。
2. 在 `_parse_tool_args` 与工具执行分支中加入“解析失败/空参数”硬性熔断，返回参数修复提示，不执行工具。
3. 在写入 `assistant_msg` 时：若携带 `tool_calls`，将 `content=None`；并提供开关，若提供方不支持就改为回传纯文本总结。
4. 在 `UpdateBasicsTool.execute` 中：检测全 None 参数时返回“未接收到有效字段，未更新”。
5. 增加最小用例验证与日志增强，确认不再出现断言与 400。

