## 背景与根因
- 现象：流式迭代报 `AssertionError: assert new_tool.type == "function"`，随后在解析工具参数处报 `JSONDecodeError`。
- 根因1（流式）：OpenAI Python 的 `chat.completions.stream` 在处理工具调用增量时强制要求工具类型为 `function`；SiliconFlow/DeepSeek 的流式事件类型与该断言不完全兼容，导致迭代中断。
- 根因2（参数）：`tc.function.arguments` 返回的值偶发不是严格的 JSON 字符串（可能是已解析的 dict 或带单引号的 Python 风格字符串、或流式未完整拼接），直接 `json.loads` 会失败。

## 改动目标
- 保留既有工具体系与调用逻辑，避免侵入式改动。
- 移除导致断言的流式路径，改用一次性响应以稳定拿到工具调用。
- 增强工具参数解析的鲁棒性，兼容字符串/字典/Python风格字符串。

## 最小改动方案
1. 将流式改为非流式：
   - 把 `with self.client.chat.completions.stream(...) as stream:` 替换为一次性调用 `self.client.chat.completions.create(...)`。
   - 仍然先 `yield` 一条“思考中”的提示，然后把最终文本一次性输出；SSE 仍正常工作，只是少了逐字增量。
   - 受影响位置：`backend/editor_agent.py:80-100`（参考当前文件结构）。

2. 工具参数解析容错：
   - 新增一个私有方法 `_parse_args(raw)`：
     - 若 `raw` 是 `dict`，直接返回；
     - 若是 `str`，先 `json.loads`；失败时回退到 `ast.literal_eval`；最终确保返回 `dict`。
   - 在两处解析点改用 `_parse_args(...)`：
     - `backend/editor_agent.py:130`（单工具独占路径）
     - `backend/editor_agent.py:150`（多工具路径）

3. 类型容错（低风险）：
   - 构造 `assistant_msg["tool_calls"]` 时继续写入 `"type": "function"`（当前代码已如此），忽略返回中可能出现的非 `function` 类型以保持兼容。

## 代码改动点
- `backend/editor_agent.py`
  - 替换流式块为非流式创建并收集 `response.choices[0].message.content` 与 `tool_calls`。
  - 在文件顶部 `import ast`，并实现 `_parse_args`。
  - 将两处 `json.loads(tc.function.arguments)`/`json.loads(tool_call.function.arguments)` 改为 `_parse_args(...)`。

## 验证方案
- 手动请求：调用 `/run`，输入如“请调用 stop 并附带 message”，确认：
  - SSE 不再出现“流式迭代异常/断言错误”。
  - 工具被正确解析与执行，前端收到“工具执行完成：stop”。
- 再次测试一个带复杂参数的业务工具（含列表/字符串），确认参数解析正常。

## 风险与兼容性
- 流式改为一次性响应会减少逐字展示，但保留了“思考中”提示与最终输出，用户体验影响较小。
- 工具体系、Pydantic 校验、互斥规则均不变；对现有前端事件流无破坏性接口变更。
